# 子数组元素个数相等

## 基本思路

leetcode [525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

- `1 <= nums.length <= 1e5`

- `nums[i]` 不是 `0` 就是 `1`

必须是相同数量，不满足能使用双指针和二分的性质。考虑前缀和：
$$
presum0[i]-presum0[j] = presum1[i]-presum1[j]
$$

$$
presum0[i]-presum1[i] = presum0[j]-presum1[j]
$$

合并同索引项后，我们可以构造一个新的数组$A[i]=presum0[i]-presum1[i]$. 那么含有相同数量0，1的连续子数组可表示为$A[i]=A[j]$. 要找最长，我们只需要记录每个数第一次出现的位置即可

## 变形

### 三种元素的数量相等

[3714. 最长的平衡子串 II](https://leetcode.cn/problems/longest-balanced-substring-ii/)
$$
A[i]-A[j]=B[i]-B[j]=C[i]-C[j] \\
A[i]-B[i]=A[j]-B[j]且C[i]-B[i] = C[j]-B[j]
$$
若A和B的数量相同且B和C的数量相同，即A=B=C。维护pair(A[i]-B[i], C[i]-B[i]), 记录每个pair第一次出现的位置。

### 不同的两种type的元素数量相同

[3721. 最长平衡子数组 II](https://leetcode.cn/problems/longest-balanced-subarray-ii/)

给你一个整数数组 `nums`。

如果子数组中 **不同偶数** 的数量等于 **不同奇数** 的数量，则称该 **子数组** 是 **平衡的** 。

返回 **最长** 平衡子数组的长度。

**子数组** 是数组中连续且 **非空** 的一段元素序列。



这个问题的难点在于，一个子数组 [i, j] 的性质（不重复元素数量）无法通过 [0, j] 和 [0, i-1] 的性质简单推导出来。

此时维护的信息有一点trick。

定义一个动态数组A, 当区间右端点为i时：
$$
A[k] = 1, k是nums[k]最后出现的位置，且nums[k]为偶数 \\
A[k] = -1, k是nums[k]最后出现的位置，且nums[k]为奇数 \\
A[k] = 0, 其它
$$
此时再求动态数组A的前缀和presum, 则以i为右端点，满足条件的最长子数组为presum[i]第一次出现的位置。

当i变化时，需要找到nums[i]之前出现的位置k，将[k, i-1]全部减val(nums[i])，将[i,i]加val(nums[i])。对于区间加减可以用线段树维护presum。

为了找到第一次出现presum[i]的位置,可以让线段树维护区间max和min，在线段树上进行二分。